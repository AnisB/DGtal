/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DifferentialOperatorsOnImages.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2011/12/19
 *
 * @brief Implementation of inline methods defined in DifferentialOperatorsOnImages.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


template <typename TImage, typename TOutputValue>
inline
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>
::DifferentialOperatorsOnImages( Image& aStartingImage )
  : myU( aStartingImage ), myH( 1 )
{
}

template <typename TImage, typename TOutputValue>
inline
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>
::DifferentialOperatorsOnImages( Image& aStartingImage, const OutputValue& aGridStep )
  : myU( aStartingImage ), myH( aGridStep )
{
}


template <typename TImage, typename TOutputValue>
inline
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>
::~DifferentialOperatorsOnImages()
{
}

template <typename TImage, typename TOutputValue>
inline
bool
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>
::isValid() const
{
    return true;
}

///////////////////////////////////////////////////////////////////////////////
// main functions                                                            //

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
forwardDifference(const Point& aPoint, const Dimension& aDim) const
{
  Point next = getNext(aPoint, aDim);
  if ( myU.domain().isInside(next) )
    return ( (myU(next) - myU(aPoint)) / myH ); 
  else 
    return backwardDifference(aPoint, aDim); 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
backwardDifference(const Point& aPoint, const Dimension& aDim) const
{
  Point previous = getPrevious(aPoint, aDim);
  if ( myU.domain().isInside(previous) )
    return ( (myU(aPoint) - myU(previous)) / myH ); 
  else 
    return forwardDifference(aPoint, aDim); 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
centralDifference(const Point& aPoint, const Dimension& aDim) const
{
  Domain d = myU.domain(); 
  Point next = getNext(aPoint, aDim);
  bool nextInside = d.isInside(next); 
  Point previous = getPrevious(aPoint, aDim);
  bool previousInside = d.isInside(previous);

  if (nextInside && previousInside )
    return ( (myU(next) - myU(previous)) / (2*myH) ); 
  else if ( nextInside && (!previousInside) )
    return ( (myU(next) - myU(aPoint)) / myH ); 
  else if ( (!nextInside) && previousInside )
    return ( (myU(aPoint) - myU(previous)) / myH ); 
  else 
    ASSERT( false && "impossible case" ) ; 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::Gradient
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
centralGradient(const Point& aPoint) const
{
  Gradient g; 
  for (Dimension k = 0; k < dimension; ++k ) 
    {
      g.at(k) = centralDifference(aPoint,k); 
    }
  return g; 
}

template <typename TImage, typename TOutputValue>
inline
double
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
centralGradientModulus(const Point& aPoint) const
{
  Gradient g = centralGradient(aPoint); 
  return g.norm(Gradient::L_2); 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::Gradient
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
upwindGradient(const Point& aPoint, const Vector& aVector) const
{
  Gradient g; 
  for (Dimension k = 0; k < dimension; ++k ) 
    {
      if (aVector.at(k) > 0) 
	g.at(k) = backwardDifference(aPoint,k); 
      else if (aVector.at(k) < 0)
	g.at(k) = forwardDifference(aPoint,k);
      else //== 0
	g.at(k) = 0; 
    }
  return g; 
}

template <typename TImage, typename TOutputValue>
inline
double
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
upwindGradientModulus(const Point& aPoint, const Vector& aVector) const
{
  Gradient g = upwindGradient(aPoint, aVector); 
  return g.norm(Gradient::L_2); 
}

template <typename TImage, typename TOutputValue>
inline
DGtal::PointVector<TImage::dimension,TOutputValue>
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
godunovGradient(const Point& aPoint, bool isPositive) const
{
  DGtal::PointVector<TImage::dimension,TOutputValue> g; 
  for (Dimension k = 0; k < dimension; ++k ) 
    {
      if (isPositive)
	{
	  OutputValue a = backwardDifference(aPoint,k);
	  if (a < 0) a = 0; 
	  OutputValue b = forwardDifference(aPoint,k);
	  if (b > 0) b = 0; 
	  g.at(k) = std::sqrt( std::max(a*a,b*b) ); 
	}
      else 
	{
	  OutputValue a = backwardDifference(aPoint,k);
	  if (a > 0) a = 0; 
	  OutputValue b = forwardDifference(aPoint,k);
	  if (b < 0) b = 0; 
	  g.at(k) = std::sqrt( std::max(a*a,b*b) ); 
	} 
    }
  return g; 
}

template <typename TImage, typename TOutputValue>
inline
double
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
godunovGradientModulus(const Point& aPoint, bool isPositive) const
{
  Gradient g = godunovGradient(aPoint, isPositive); 
  return g.norm(Gradient::L_2); 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
forwardBackwardDifference2(const Point& aPoint, const Dimension& aDim) const
{
  Domain d = myU.domain(); 
  Point next = getNext(aPoint, aDim);
  bool nextInside = d.isInside(next); 
  Point previous = getPrevious(aPoint, aDim);
  bool previousInside = d.isInside(previous);
 
  if (nextInside && previousInside )
    return ( (myU(next) - 2*myU(aPoint) + myU(previous) ) / (myH*myH) ); 
  else 
    return 0;   
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
laplacian(const Point& aPoint) const
{
  OutputValue sum = 0; 
  for (Dimension k = 0; k < dimension; ++k ) 
    {
      sum += forwardBackwardDifference2(aPoint,k); 
    }
  return sum; 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
weightedDifference2(TImage& w, const Point& aPoint, const Dimension& aDim) const
{

  Domain d = myU.domain(); 
  ASSERT(w.domain().lowerBound() == d.lowerBound()); 
  ASSERT(w.domain().upperBound() == d.upperBound()); 

  Point next = getNext(aPoint, aDim);
  bool nextInside = d.isInside(next); 
  Point previous = getPrevious(aPoint, aDim);
  bool previousInside = d.isInside(previous);
  double mod = centralGradientModulus(aPoint); 

  if (nextInside && previousInside )
    {
      double nMod = centralGradientModulus(next); 
      double pMod = centralGradientModulus(previous); 
      return ( ( normalizedAverage(w(next),nMod,w(aPoint),mod)*(myU(next) - myU(aPoint)) )
	       - ( normalizedAverage(w(aPoint),mod,w(previous),pMod)*(myU(aPoint) - myU(previous)) ) 
	     / NumberTraits<Value>::castToDouble(myH*myH) ); 
    }
  else if ( (!nextInside) && previousInside )
    {
      double pMod = centralGradientModulus(previous); 
      return ( ( ( w(aPoint) - normalizedAverage(w(previous),pMod,w(aPoint),mod) )
		 *(myU(aPoint) - myU(previous)) ) 
	     / NumberTraits<Value>::castToDouble(myH*myH) );
    } 
   else if ( (!nextInside) && previousInside )
     {
       double nMod = centralGradientModulus(next); 
       return ( ( ( normalizedAverage(w(next),nMod,w(aPoint),mod) - w(aPoint) )
		*(myU(next) - myU(aPoint)) ) 
	      / NumberTraits<Value>::castToDouble(myH*myH) ); 
     }
  else 
    ASSERT( false && "impossible case" ) ; 
  
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
normalizedDifference2(const Point& aPoint, const Dimension& aDim) const
{

  Domain d = myU.domain(); 
  Point next = getNext(aPoint, aDim);
  bool nextInside = d.isInside(next); 
  Point previous = getPrevious(aPoint, aDim);
  bool previousInside = d.isInside(previous);
  double mod = centralGradientModulus(aPoint); 

  if (nextInside && previousInside )
    {
      double nMod = centralGradientModulus(next); 
      double pMod = centralGradientModulus(previous);   
      return ( ( normalizedAverage(1,nMod,1,mod)*(myU(next) - myU(aPoint)) )
	       - ( normalizedAverage(1,mod,1,pMod)*(myU(aPoint) - myU(previous)) ) 
	       / NumberTraits<Value>::castToDouble(myH*myH) ); 
    }
  else if ( (!nextInside) && previousInside )
    {
      double pMod = centralGradientModulus(previous); 
      return ( ( ( 1 - normalizedAverage(1,pMod,1,mod) )
		 *(myU(aPoint) - myU(previous)) ) 
	     / NumberTraits<Value>::castToDouble(myH*myH) );
    } 
   else if ( (!nextInside) && previousInside )
     {
       double nMod = centralGradientModulus(next); 
       return ( ( ( normalizedAverage(1,nMod,1,mod) - 1 )
		*(myU(next) - myU(aPoint)) ) 
	      / NumberTraits<Value>::castToDouble(myH*myH) ); 
     }
  else 
    ASSERT( false && "impossible case" ) ; 
  
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
weightedMeanCurvature(Image& aImg, const Point& aPoint) const
{
  OutputValue sum = 0; 
  for (Dimension k = 0; k < dimension; ++k ) 
    {
      sum += weightedDifference2(aImg, aPoint,k); 
    }
  return sum; 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::OutputValue
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
meanCurvature(const Point& aPoint) const
{
  OutputValue sum = 0; 
  for (Dimension k = 0; k < dimension; ++k ) 
    {
      sum += normalizedDifference2(aPoint,k); 
    }
  return sum; 
}


///////////////////////////////////////////////////////////////////////////////
// Internals                                                                 //

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::Point
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
getNext(const Point& aPoint, const Dimension& aDim) const
{
  Point next(aPoint); 
  next.at(aDim) += 1; 
  return next; 
}

template <typename TImage, typename TOutputValue>
inline
typename DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::Point
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
getPrevious(const Point& aPoint, const Dimension& aDim) const
{
  Point p(aPoint); 
  p.at(aDim) -= 1; 
  return p; 
}

template <typename TImage, typename TOutputValue>
inline
double
DGtal::DifferentialOperatorsOnImages<TImage, TOutputValue>::
normalizedAverage( const Value& aV1, const double& aN1, 
		   const Value& aV2, const double& aN2 ) const
{
  ASSERT(aV1 != 0);
  ASSERT(aV2 != 0);
  double q1 = aN1 / NumberTraits<Value>::castToDouble(aV1);
  double q2 = aN2 / NumberTraits<Value>::castToDouble(aV2); 
  double som = q1 + q2; 
  if (som == 0) return 0; 
  else return 2/som;   
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


